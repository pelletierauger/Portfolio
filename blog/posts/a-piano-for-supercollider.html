<!-- year -->2020
<!-- month -->02
<!-- day -->17
<!-- fr-title -->Un piano pour SuperCollider
<!-- fr-description -->Écrire un échantillonneur pour un piano acoustique.
<!-- fr-content -->

<pn>
    So this is the entirety of the code for the sampler:
</pn>

<supercollider>
(
var pianoSamples, pianoFolder, makeLookUp, indices, pitches;

pianoSamples = Array.new;
pianoFolder = PathName.new("/21055__samulis__vsco-2-ce-keys-upright-piano/");
pianoFolder.entries.do({
    |path|
    pianoSamples = pianoSamples.add(Buffer.read(s, path.fullPath));
});

makeLookUp = {
    |note, dynamic|
    var octave = floor(note / 12) - 1;
    var degree = note - 24 % 12;
    var noteDeltas = [-1, 0,  1,  2, -1,  0,  1, -2, -1,  0,  1,  2];
    var pitch = noteDeltas[degree].midiratio;
    var sampledNote = [1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  3,  3];
    var sampleToGet = (octave - 1) * 3 + sampledNote[degree];
    var dynamicOffset = dynamic - 1 * 23;
    sampleToGet = sampleToGet + dynamicOffset;
    [sampleToGet, pitch];
};
indices = 3.collect({|j| (20..110).collect({|i| makeLookUp.(i, j + 1)[0]})}).flat;
pitches = 3.collect({|j| (20..110).collect({|i| makeLookUp.(i, j + 1)[1]})}).flat;

Event.addEventType(\pianoEvent, {
    var index;
    if (~num.isNil, {~num = 60}, {~num = floor(min(max(20, ~num), 110))});
    if (~dyn.isNil, {~dyn = 0}, {~dyn = floor(min(max(0, ~dyn), 2))});
    index = ~num - 20 + (~dyn * 91);
    ~buf = pianoSamples[indices[index]];
    ~rate = pitches[index];
    ~instrument = \pianoSynth;
    ~type = \note;
    currentEnvironment.play;
});
)
</supercollider>

<pn>
    Here is two instances of <ic>PBind</ic> that give an example of how the piano sampler can be used, using the custom <ic>Event</ic> named <ic>\pianoEvent</ic>. I recommend running both patterns at the same, they are made to complement each other.
</pn>

<supercollider>
(
var key = 62;
var notes = key + ([0, 3, 7, 10] ++ [-5, 2, 3, 9]);
~pianoRiff.stop;
~pianoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq(0.5!1 ++ (0.25!3), inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 0, 0, 1], inf),
    \amp, Pseq([0.5, 2, 2, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)

(
var key = 62 + 36;
var notes = key + [2, -5, 0, -2];
~pianoRiff2.stop;
~pianoRiff2 = Pbind(
    \type, \pianoEvent,
    \dur, Pseq([0.25, 1.75], inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 1, 1, 1], inf),
    \amp, Pseq([0.5, 1, 1, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)
</supercollider>

<pn>
    And below is a variant which doesn't load the samples at the highest dynamic, because I personally almost never use them. I tend to write quiet music so I don't have much use for loud samples, so loading them is a waste of memory.
</pn>
<supercollider>
(
var pianoSamples, pianoFolder, makeLookUp, indices, pitches;

pianoSamples = Array.new;
pianoFolder = PathName.new("/21055__samulis__vsco-2-ce-keys-upright-piano/");
pianoFolder.entries.do({
    |path, i|
    if (i < 46, {
        pianoSamples = pianoSamples.add(Buffer.read(s, path.fullPath));
    });
});

makeLookUp = {
    |note, dynamic|
    var octave = floor(note / 12) - 1;
    var degree = note - 24 % 12;
    var noteDeltas = [-1, 0,  1,  2, -1,  0,  1, -2, -1,  0,  1,  2];
    var pitch = noteDeltas[degree].midiratio;
    var sampledNote = [1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  3,  3];
    var sampleToGet = (octave - 1) * 3 + sampledNote[degree];
    var dynamicOffset = dynamic - 1 * 23;
    sampleToGet = sampleToGet + dynamicOffset;
    [sampleToGet, pitch];
};
indices = 2.collect({|j| (20..110).collect({|i| makeLookUp.(i, j + 1)[0]})}).flat;
pitches = 2.collect({|j| (20..110).collect({|i| makeLookUp.(i, j + 1)[1]})}).flat;

Event.addEventType(\pianoEvent, {
    var index;
    if (~num.isNil, {~num = 60}, {~num = floor(min(max(20, ~num), 110))});
    if (~dyn.isNil, {~dyn = 0}, {~dyn = floor(min(max(0, ~dyn), 1))});
    index = ~num - 20 + (~dyn * 91);
    ~buf = pianoSamples[indices[index]];
    ~rate = pitches[index];
    ~instrument = \pianoSynth;
    ~type = \note;
    currentEnvironment.play;
});

</supercollider>

<!-- en-title -->A piano for SuperCollider
<!-- en-description -->Writing an acoustic piano multi-sampler.
<!-- en-content -->

<pn>
    <sc>In the winter of 2019</sc>, I started to work on an acoustic piano multi-sampler for SuperCollider. The earliest versions had many issues, and my budding programming skills in <ic>sclang</ic> did not allow me to fix them. But I've used the instrument a lot since then, and I've improved the code along the way. I plan to keep working on the instrument as I keep using it, but I'm thinking that it could already be useful for other people if they are interested. So here it is.
</pn>
<p>
    The instrument uses <a href="https://freesound.org/people/Samulis/packs/21055/">a public domain sample &nbsn;pack</a><snl label="etude">I used this same sample pack for a piece of music that I wrote for my short film <a href="https://www.youtube.com/watch?v=sOEmaJY6h6M"><i8>Étude for Cellular Automata no 2</i8></a>. I composed this piece with Ableton Live because I didn't know about SuperCollider at the time. The piece uses only one or two samples in the pack, as I had found that building a good multi-sampler with Ableton Live was mostly a nightmare. I also used the piano samples in <a href="https://www.youtube.com/watch?v=COeC7UdIBn8">this live coding experiment</a> which was one of my first SuperCollider projects.</snl>that you can download from <a href="https://freesound.org/">freesound.org</a>. You'll need to create an account to download it, but it's free to join, and free to download, and I highly recommend this website.
</p>
<p>
    Below is the entirety of the code for the sampler, along with some <ic>Pbind</ic> examples to try it out. It is <sc>free software</sc> distributed under an <a href="http://www.apache.org/licenses/LICENSE-2.0.txt">Apache <lnum>2.0</lnum> licence</a>. You can also <a href="">find this code on GitHub</a>.
</p>

<supercollider>
// Run this block of code once the server is booted.
// You also need to make sure that the packLocation variable
// is set to the actual location of the downloaded sample pack.

(
var pianoSamples, pianoFolder, makeLookUp, indices, pitches, dynAmnt, maxDyn, maxNote,
packLocation = "/21055__samulis__vsco-2-ce-keys-upright-piano/",
quiet = false;

dynAmnt = if (quiet, {2}, {3});
maxDyn = if (quiet, {1}, {2});
maxNote = if (quiet, {46}, {1e2});
pianoSamples = Array.new;
pianoFolder = PathName.new(packLocation);
pianoFolder.entries.do({
    |path, i|
    if (i < maxNote, {
        pianoSamples = pianoSamples.add(Buffer.read(s, path.fullPath));
    });
});

makeLookUp = {
    |note, dynamic|
    var octave = floor(note / 12) - 2;
    var degree = note % 12;
    var sampledNote = [1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  3,  3];
    var noteDeltas = [-1, 0,  1,  2, -1,  0,  1, -2, -1,  0,  1,  2];
    var dynamicOffset = dynamic * 23;
    var sampleToGet = octave * 3 + sampledNote[degree] + dynamicOffset;
    var pitch = noteDeltas[degree];
    [sampleToGet, pitch];
};
indices = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[0]})}).flat;
pitches = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[1]})}).flat;

Event.addEventType(\pianoEvent, {
    var index;
    if (~num.isNil, {~num = 60}, {~num = min(max(20, ~num), 110)});
    if (~dyn.isNil, {~dyn = 0}, {~dyn = floor(min(max(0, ~dyn), maxDyn))});
    index = floor(~num) - 20 + (~dyn * 91);
    ~buf = pianoSamples[indices[index]];
    ~rate = (pitches[index] + frac(~num)).midiratio;
    ~instrument = \pianoSynth;
    ~type = \note;
    currentEnvironment.play;
});

SynthDef(\pianoSynth, {
    arg buf = pianoSamples[0], rate = 1, spos = 0, pan = 0, amp = 1, out = 0, atk = 0, sus = 0, rel = 8;
    var sig, env;
    env = EnvGen.kr(Env.new([0, 1, 1, 0], [atk, sus, rel]), doneAction: 2);
    sig = PlayBuf.ar(2, buf, rate * BufRateScale.ir(buf), startPos: spos, doneAction: 2);
    sig = sig * amp * 18 * env;
    sig = Balance2.ar(sig[0], sig[1], pan, 1);
    Out.ar(out, sig);
}).add;
)

// Below are examples of patterns that show how to use the instrument.
// I recommend running both patterns at the same time,
// they are made to complement each other.

(
var key = 62;
var notes = key + ([0, 3, 7, 10] ++ [-5, 2, 3, 9]);
~pianoRiff.stop;
~pianoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq(0.5!1 ++ (0.25!3), inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 0, 0, 1], inf),
    \amp, Pseq([0.5, 2, 2, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)

(
var key = 62 + 36;
var notes = key + [2, -5, 0, -2];
~pianoRiff2.stop;
~pianoRiff2 = Pbind(
    \type, \pianoEvent,
    \dur, Pseq([0.25, 1.75], inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 1, 1, 1], inf),
    \amp, Pseq([0.5, 1, 1, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)

(
~pianoRiff.stop;
~pianoRiff2.stop;
)
</supercollider>

<h3>How to use the sampler</h3>

<pn>
    <sc>Using the instrument</sc> will probably be very straightforward for most users of SuperCollider, but I thought that writing down some instructions could still be useful, particularly for beginners. It's also an opportunity to talk about the design decisions that went into creating the instrument, and the ways in which it could potentially be improved.
</pn>
<!-- read-more -->
<p>
    My main goal for this project was to use the piano with instances of <ic>Pbind</ic> that would be as uncluttered as possible. Here is a <ic>Pbind</ic> that uses all features of the instrument:
</p>

<supercollider>
(
var key = 62;
var notes = key + ([0, 3, 7, 10] ++ [-5, 2, 3, 9]);
~pianoRiff.stop;
~pianoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq(0.5!1 ++ (0.25!3), inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 0, 0, 1], inf),
    \amp, Pseq([0.5, 2, 2, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)
</supercollider>

<pn>
    The instrument is played by using a custom event type named <ic>\pianoEvent</ic>. This event type computes all the logic behind the instrument and leaves all of that out of the <ic>Pbind</ic>. The notes that you want to play must be defined with the <ic>\num</ic> &nbsn;key.<snl label="num">I wanted to use the <ic8>\note</ic8> key but <ic8>Pbind</ic8> seems to have some internal functionality for this key.</snl> The notes can be between <ic>20</ic> and <ic>110</ic>. These are standard <sc>midi</sc> note values, <ic>20</ic> being a G#-1 and <ic>110</ic> being a D8. There are &ldquo;safety measures&rdquo; in the instrument, so if you ask for notes below <ic>20</ic> or above <ic>110</ic> it'll give you the closest available note (so <ic>20</ic> or <ic>110</ic>). Negative notes will return <ic>20</ic>. Notably, if you ask for a non-integer note like <ic>50.5</ic>, it will give you a note between <ic>50</ic> and <ic>51</ic>. Any non-integer values work, which makes this instrument usable for microtonal music.
</pn>
<p>
    Each note in the sample pack exists in three different levels of loudness (or dynamics) from quiet, to medium, to loud. The dynamic of the note that will be played is defined by the <ic>\dyn</ic> key in the <ic>Pbind</ic>. <ic>\dyn</ic> can either be <ic>0</ic>, <ic>1</ic>, or <ic>2</ic>. The safety measures will floor this <ic>\dyn</ic> value, so a loudness of <ic>0.9</ic> will return <ic>0</ic>. A loudness above <ic>2</ic> will return <ic>2</ic>, and negative values will return <ic>0</ic>. A <ic>Pbind</ic> that does not include a <ic>\dyn</ic> key will default to a value of <ic>0</ic>.
</p>
<p>
    The <ic>\amp</ic> key in the <ic>Pbind</ic> simply scales the amplitude of the note. It has no effect on which level of dynamics is played. The instrument also has optional <ic>atk</ic>, <ic>sus</ic>, and <ic>dec</ic> arguments, for attack, sustain, and decay. These are useful mainly because the noise floor in the samples is quite high, so you may want to limit the duration over which a note is played, to reduce the noise.
</p>

<h3>The <ic>quiet</ic> mode</h3>

<pn>
    <sc>You can see</sc> near the top of the code a line that goes: <ic>quiet = false</ic>. If you change this to <ic>true</ic> before you evaluate the code, it will prevent the loud samples from being loaded. I wrote this option because I personally never use the loud samples. I tend to write quiet music and I don't have much use for loud sounds, so loading them is a waste of memory (perhaps a very small waste, but a waste nonetheless). In this quiet mode, a <ic>\dyn</ic> value above <ic>1</ic> in the <ic>Pbind</ic> will return <ic>1</ic>, because the samples with a dynamic of <ic>2</ic> will not be loaded.
</pn>

<h3>How it all works</h3>

<pn>
    <sc>The sample pack contains</sc> three samples per octave: C#, F, and A. The basic <i>modus operandi</i> of the sampler is to take a note that you want to play and look for the closest note that it can find in the pack. And then, if the closest note is not the exact one that you asked for, the sampler has to play this closest note at a different pitch to produce the desired note. So if you want a C, it will play the recorded C# note at a pitch ratio of <span class="constrain-line"><im>\big(2^{1/12}\big)^{-1}</im></span> because the desired note is <im>-1</im> note away from the closest &nbsn;note.<snl label="temperament"> This bit of mathematics is how the <a href="https://en.wikipedia.org/wiki/Equal_temperament">twelve-tone equal temperament</a> is built.</snl> Any distance <im>n</im> between the desired note and the available note will similarly result in the available note being played at a ratio of <span class="constrain-line"><im>\big(2^{1/12}\big)^{n}</im></span> to obtain the desired note.
</pn>
<p>
    In the code box below you can see how each octave is built, starting on the note C. For each degree of the octave, we define which sample will be used in the <ic>sampledNote</ic> variable: C# is <ic>1</ic>, F is <ic>2</ic>, and A is <ic>3</ic>. In the <ic>noteDeltas</ic> variable, we define the distance (or interval) between the note that we want, and the closest available note. So it follows that for C#, F, and A, the value in <ic>noteDeltas</ic> is <ic>0</ic>. And since <span class="constrain-line"><im>\big(2^{1/12}\big)^{0} = 1</im></span>, these notes will be played at a pitch ratio of <ic>1</ic>.
</p>

<supercollider>
var sampledNote = [1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  3,  3];
var noteDeltas = [-1, 0,  1,  2, -1,  0,  1, -2, -1,  0,  1,  2];
</supercollider>

<pn>
    These two lines of code are found in the <ic>makeLookUp()</ic> function, which is used to create two lookup tables that will then be used when the instrument is &nbsn;played.<snr label="lookup">The purpose of a lookup table is to prepare data that will be used frequently instead of running an algorithm that generates the same data every time. In this case, the calculations are really simple and fast, but I thought that lookup tables were still an interesting way to organize the program and make it theoretically even faster (but mostly I just wanted to experiment with lookup tables).</snr> The lines below is where we run this <ic>makeLookUp()</ic> function and build the two lookup tables, one for the indices of the available closest buffers and one for the pitch ratios at which the notes will be played. You can see two nested loops here: one loop over the <ic>dynAmnt</ic> value, which is the amount of different dynamics that will be available, and the other loop over an <ic>Array</ic> that goes from <ic>20</ic> to <ic>110</ic>, which is a list of all available notes.
</pn>

<supercollider>
indices = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[0]})}).flat;
pitches = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[1]})}).flat;
</supercollider>

<pn>
    The <ic>\pianoEvent</ic> event type is where the lookup tables are used. It's also where the numbers defined in a <ic>Pbind</ic> are sanitized (you can see the <ic>~num</ic> and <ic>~dyn</ic> variables being constrained with <ic>min()</ic> and <ic>max()</ic> &nbsn;operators),<snl label="envir">It's confusing but the keys that were defined in the <ic8>Pbind</ic8>, like <ic8>\num</ic8> and <ic8>\dyn</ic8>, they are referred to as <ic8>~num</ic8> and <ic8>~dyn</ic8> within the <ic8>Event</ic8> that the <ic8>Pbind</ic8> activates. The <ic8>~</ic8> before the variable names means that they are environment variables, the environment being the <ic8>Event</ic8> itself.</snl> and where the microtonality is made possible.
</pn>

<supercollider>
Event.addEventType(\pianoEvent, {
    var index;
    if (~num.isNil, {~num = 60}, {~num = min(max(20, ~num), 110)});
    if (~dyn.isNil, {~dyn = 0}, {~dyn = floor(min(max(0, ~dyn), maxDyn))});
    index = floor(~num) - 20 + (~dyn * 91);
    ~buf = pianoSamples[indices[index]];
    ~rate = (pitches[index] + frac(~num)).midiratio;
    ~instrument = \pianoSynth;
    ~type = \note;
    currentEnvironment.play;
});
</supercollider>

<pn>
    The microtonality is calculated on the line where the variable <ic>~rate</ic> is defined. By taking the fractional value of <ic>~num</ic> and by adding it to the &ldquo;note delta&rdquo; that was previously computed in the creation of the lookup table, we obtain the final distance between the desired note and the available note, and we pass this distance to the <ic>midiratio</ic> operator, which is doing the same calculation as above: <span class="constrain-line"><im>\big(2^{1/12}\big)^{n}</im></span> where <im>n</im> is the input. This fractional value is only present when the notes you ask for are not integers&mdash;when you are playing with microtonality.
</pn>

<h3>Final thoughts</h3>

<pn>
    <sc>I really enjoyed</sc> putting this project together and it made me appreciate the strange and often confusing beauty of <ic>sclang</ic> even more. If you end up using the sampler, I'd love to have feedback on it or hear what you make with it. Don't hesitate to <a href="https://pelletierauger.com/en/about.html#contact">contact me</a> with comments or questions.
</pn>